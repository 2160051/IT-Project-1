# -*- coding: utf-8 -*-
"""k-means.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10TSvtrHbDgrwdiSmFlewWXoPIC5EKwOE
"""

# %matplotlib inline
import numpy as np  
import pandas as pd
import matplotlib.pyplot as plt  
from sklearn.cluster import KMeans
from mpl_toolkits.mplot3d import Axes3D
#feature selection
from sklearn.ensemble import ExtraTreesClassifier
#silhoutte coefficient
from sklearn import metrics
from sklearn.metrics import pairwise_distances
from sklearn import datasets
#elbow curve
from scipy.spatial.distance import cdist
#unused
import seaborn as sns
from sklearn import datasets
from sklearn import metrics
from sklearn.linear_model import LinearRegression
from sklearn.naive_bayes import ComplementNB
from sklearn.naive_bayes import GaussianNB
from sklearn.naive_bayes import MultinomialNB
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import KBinsDiscretizer
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import ComplementNB

"""K-means Clustering

Step 1: Load dataset
"""

#link(github file: https://github.com/2160051/IT-Project-1/blob/master/Data%20Analytics.csv)
link = 'https://raw.githubusercontent.com/2160051/IT-Project-1/master/Data%20Analytics.csv'
plotdata = pd.read_csv(link)

#Multiple Attributes - multiple variables
xattributes = plotdata[['Population_Density(km²)', 'TAVE', 'Glaciers', 'Locales', 'Beaches', 'Areas', 'Lakes', 'Streams', 'Swamps', 'Forests', 'Plains', 'Woods']]
xattributes = xattributes[:50] #only using the first 50 rows
xattributes = np.array(xattributes)

#X
xdata = plotdata[['Population_Density(km²)']] #used population density as the sample
xdata = xdata[:50]
xdata = np.array(xdata['Population_Density(km²)'].values)

#Y
ydata = plotdata[['Person-to-Person Contact']]
ydata = ydata[:50] #only using the first 50 rows
ydata = np.array(ydata['Person-to-Person Contact'].values)

"""Step 2: Identify number of clusters

Step 3: Create the clustered scatter plot
"""

plt.rcParams['figure.figsize'] = (16, 9)
plt.style.use('ggplot')
scatterplot = np.array(list(zip(xdata, ydata)))
kmeans = KMeans(n_clusters=4) #low, medium, high, very high
kmeans = kmeans.fit(scatterplot)
datacentroids = kmeans.cluster_centers_
print("Clusters:")
print(datacentroids.tolist()) 
plt.scatter(scatterplot[:, 0], scatterplot[:, 1], c=kmeans.labels_, cmap='rainbow') 
plt.scatter(datacentroids[:, 0], datacentroids[:, 1], c='black', s=100, alpha=0.5)  
plt.xlabel('Population_Density(km²)')
plt.ylabel('Total Number of Cases Categorized as Person-to-Person Contact')
plt.title('Scatter Plot with KMeans Clusters')
plt.show()

"""Silhoutte Coefficient - performance evaluation"""

#https://scikit-learn.org/stable/modules/clustering.html#silhouette-coefficient
kmeans_model = KMeans(n_clusters=4, random_state=1).fit(scatterplot)
labels = kmeans_model.labels_
metrics.silhouette_score(scatterplot, labels, metric='euclidean')

"""Elbow Curve - to identify the optimal number of clusters"""

#https://pythonprogramminglanguage.com/kmeans-elbow-method/
Xplot = np.array(list(zip(xdata, ydata)))
distortions = []
K = range(1,10)
for k in K:
    kmeanModel = KMeans(n_clusters=k).fit(Xplot)
    kmeanModel.fit(Xplot)
    distortions.append(sum(np.min(cdist(Xplot, kmeanModel.cluster_centers_, 'euclidean'), axis=1)) / Xplot.shape[0])

plt.plot(K, distortions, 'bx-')
plt.xlabel('k')
plt.ylabel('Distortion')
plt.title('Elbow Method Graph for the Optimal k')
plt.show()

#https://scikit-learn.org/stable/modules/clustering.html#silhouette-coefficient
kmeans_model = KMeans(n_clusters=4, random_state=1).fit(Xplot)
labels = kmeans_model.labels_
metrics.silhouette_score(Xplot, labels, metric='euclidean')
print(labels)

"""Multiple Features

3D
"""

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

#X
xt = plotdata[['Population_Density(km²)']] #used population density as the sample
xt = xt[:50]
xt = np.array(xt['Population_Density(km²)'].values)

#Y
yt = plotdata[['Person-to-Person Contact']]
yt = yt[:50] #only using the first 50 rows
yt = np.array(yt['Person-to-Person Contact'].values)

#Z
zt = plotdata[['GDP per capita']]
zt = zt[:50] #only using the first 50 rows
zt = np.array(zt['GDP per capita'].values)

ax.scatter(xt, yt, zt)
ax.set_xlabel('Population_Density')
ax.set_ylabel('Number of Cases')
ax.set_zlabel('GDP per Capita')
ax.axis('tight')

tscatterplot = np.array(list(zip(xt, yt, zt)))
kmeans = KMeans(n_clusters=4) #low, medium, high, very high
kmeans = kmeans.fit(tscatterplot)
tdatacentroids = kmeans.cluster_centers_
print("Clusters:")
print(tdatacentroids.tolist()) 
ax.scatter(tscatterplot[:, 0], tscatterplot[:, 1], tscatterplot[:, 2], c=kmeans.labels_, cmap='rainbow') 
ax.scatter(tdatacentroids[:, 0], tdatacentroids[:, 1], tdatacentroids[:, 2], c='black', s=50, alpha=0.5)  
plt.title('Number of cases, GDP and population density')
plt.show()

"""(Removed) Feature Selection - to choose attributes which can be logically used"""

#https://machinelearningmastery.com/feature-selection-machine-learning-python/
#array = np.array(plotdata.values)
#Xs = array[:,48:71]
#Ys = array[:,48]
#Ys = Ys.astype('int')
# feature extraction
#model = ExtraTreesClassifier()
#model.fit(Xs, Ys)
#print(model.feature_importances_)

"""More than 3 attributes"""

#https://githubcom/joaocarvalhoopen/Excel_table_clustering_using_K-Means_ML/blob/master/Excel_table_clustering_code_using_K-Means_in_Python.ipynb
clusters = 4
df = plotdata.copy(deep=True)
firstcolumn = df.columns[0] #index column
df.drop([firstcolumn], axis = 1, inplace = True)
df = df.drop('State', 1)
df = df.drop('Week', 1)
km = KMeans(n_clusters=clusters, random_state=1)
new = df._get_numeric_data()
km.fit(new)
predict=km.predict(new)
centroids = km.cluster_centers_
dfkmeans = df.copy(deep=True)
dfkmeans['KMeans Cluster'] = pd.Series(predict, index=dfkmeans.index)
kmeanstable = plotdata.copy(deep=True)
kmeanstable['KMeans Cluster'] = pd.Series(predict, index=dfkmeans.index)
indexcolumn = kmeanstable.columns[0]
kmeanstable.drop(indexcolumn, axis = 1, inplace = True)
print(kmeanstable.to_string())
print(centroids)

"""Graphs based on Cluster"""

#group rows based on number of clusters
for i in range(0, clusters):
  use = kmeanstable[kmeanstable['KMeans Cluster'] == i]
  clusterx = use['Population_Density(km²)']
  clustery = use['Person-to-Person Contact']
  #graph cluster attributes
  plt.rcParams['figure.figsize'] = (16, 9)
  plt.style.use('ggplot')
  clusterscatterplot = np.array(list(zip(clusterx, clustery)))
  kmeans = KMeans(n_clusters=4) #low, medium, high, very high
  kmeans = kmeans.fit(clusterscatterplot)
  datacentroids = kmeans.cluster_centers_
  print("Cluster "+str(i))
  print("Clusters:")
  print(datacentroids.tolist()) 
  plt.scatter(clusterscatterplot[:, 0], clusterscatterplot[:, 1], c=kmeans.labels_, cmap='rainbow') 
  plt.scatter(datacentroids[:, 0], datacentroids[:, 1], c='black', s=100, alpha=0.5)  
  plt.xlabel('Population_Density(km²)')
  plt.ylabel('Total Number of Cases Categorized as Person-to-Person Contact')
  plt.title('Scatter Plot with KMeans Clusters')
  plt.show()
  i+=1